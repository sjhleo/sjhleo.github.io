import{o as l,c as t,b as e,d as n}from"./app.0f37f8f2.js";const i='{"title":"HTTP","description":"","frontmatter":{"title":"HTTP"},"headers":[{"level":3,"title":"http1.0 -> http1.1","slug":"http1-0-http1-1"},{"level":3,"title":"http1.1 -> http2.0","slug":"http1-1-http2-0"},{"level":3,"title":"缓存","slug":"缓存"}],"relativePath":"note/http.md","lastUpdated":1624897638208}',a={},u=e("h3",{id:"http1-0-http1-1"},[e("a",{class:"header-anchor",href:"#http1-0-http1-1","aria-hidden":"true"},"#"),n(" http1.0 -> http1.1")],-1),h=e("ul",null,[e("li",null,"引入了更多的缓存控制策略，如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等"),e("li",null,"HTTP/1.1 允许范围请求，即在请求头中加入 Range 头部"),e("li",null,"HTTP/1.1 的请求消息和响应消息都必须包含 Host 头部，以区分同一个物理主机中的不同虚拟主机的域名"),e("li",null,"keepalive 重用 TCP 链接，实现 HTTP 长链接,在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟")],-1),d=e("h3",{id:"http1-1-http2-0"},[e("a",{class:"header-anchor",href:"#http1-1-http2-0","aria-hidden":"true"},"#"),n(" http1.1 -> http2.0")],-1),r=e("ul",null,[e("li",null,"二进制分帧"),e("li",null,"多路复用 (Multiplexing) / 连接共享"),e("li",null,"头部压缩（Header Compression）"),e("li",null,"请求优先级（Request Priorities）"),e("li",null,"服务端推送（Server Push）")],-1),p=e("h3",{id:"缓存"},[e("a",{class:"header-anchor",href:"#缓存","aria-hidden":"true"},"#"),n(" 缓存")],-1),o=e("h4",{id:"强缓存"},[e("a",{class:"header-anchor",href:"#强缓存","aria-hidden":"true"},"#"),n(" 强缓存")],-1),s=e("p",null,[e("img",{src:"/assets/http强缓存.6782225d.png",alt:"强缓存"})],-1),c=e("p",null,"主要查看 header 头中的 Expire 和 Cache-control 来判断是否满足规则",-1),f=e("ul",null,[e("li",null,"Expire")],-1),T=e("p",null,"  这个字段包含了一个时间，过了这个时间，响应将会失效，通过设置 Expire 来设置缓存有一个致命缺点：如果我修改了客户端的本地时间，就会导致判断缓存失效。",-1),g=e("ul",null,[e("li",null,"Cache-Control")],-1),M=e("p",null,[n("  在 HTTP/1.1 中，增加了一个字段 Cache-Control ，它包含一个 max-age 属性，该字段表示资源缓存的最大有效时间，这就是一个相对时间。 "),e("code",null,"Cache-Control:max-age=600"),n(" 单位为秒")],-1),C=e("p",null,"除此之外还有部分属性:",-1),E=e("table",null,[e("thead",null,[e("tr",null,[e("th",null,"属性"),e("th")])]),e("tbody",null,[e("tr",null,[e("td",null,"no-cache"),e("td",null,"需要进行协商缓存，发送请求到服务器确认是否使用缓存")]),e("tr",null,[e("td",null,"no-store"),e("td",null,"禁止使用缓存，每一次都要重新请求数据")]),e("tr",null,[e("td",null,"public"),e("td",null,"默认设置")]),e("tr",null,[e("td",null,"private"),e("td",null,"不能被多用户共享")])])],-1),P=e("p",null,"Cache-Control 的优先级别高于 Expire",-1),m=e("h4",{id:"协商缓存"},[e("a",{class:"header-anchor",href:"#协商缓存","aria-hidden":"true"},"#"),n(" 协商缓存")],-1),I=e("p",null,[n("如果强缓存没有命中，会采用协商缓存策略 "),e("img",{src:"/assets/http协商缓存.f06d062f.png",alt:"协商缓存"})],-1),x=e("ol",null,[e("li",null,"把资源标识，比如 If-Modify-Since 或 Etag 发送到服务器，确认资源是否更新"),e("li",null,"如果资源未更新，返回 304 标识，带回 Not Modified 字符串，直接使用浏览器缓存"),e("li",null,"如果资源更新，返回 200 和新的数据。"),e("li",null,"根据返回的数据更新缓存")],-1),H=e("ul",null,[e("li",null,[e("p",null,"Last-Modified，If-Modified-Since"),e("p",null,"  第一次请求资源的时候，服务器在 header 中返回 Last-Modified 字段，这是服务器资源的最后修改时间 浏览器再次请求该资源时，会将第一次 Last-Modified 字段的值作为 If-Modified-Since 的值一起发送给服务器，服务器会对比资源当前的 Last-Modified(可能已经不是第一次返回的值了)和浏览器请求中的 If-Modified-Since 的值，如果相等，说明资源还没有发生变化，直接返回 304，否则返回新的资源。")]),e("li",null,[e("p",null,"ETag， If-None-Match"),e("p",null,"  一般由文件 hash 生成，也就是资源的唯一标识，资源变化则 ETag 不一样。 首次请求资源时，服务器会返回一个 ETag 标识，再次请求时会将首次 ETag 的值作为 If-None-Match 的值一起发送给服务器，服务器会对比此时资源的 ETag 和请求头中的 If-None-Match，如果相同，则直接返回 304。否则返回新的资源 ETag 的优先级高于 Last-Modified")])],-1);a.render=function(e,n,i,a,v,S){return l(),t("div",null,[u,h,d,r,p,o,s,c,f,T,g,M,C,E,P,m,I,x,H])};export default a;export{i as __pageData};
